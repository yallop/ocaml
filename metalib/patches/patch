diff --git a/.depend b/.depend
index 4513260..74fa081 100644
--- a/.depend
+++ b/.depend
@@ -332,6 +332,21 @@ typing/tast_mapper.cmx : typing/typedtree.cmx typing/env.cmx \
     parsing/asttypes.cmi typing/tast_mapper.cmi
 typing/tast_mapper.cmi : typing/typedtree.cmi typing/env.cmi \
     parsing/asttypes.cmi
+typing/trx.cmo : utils/warnings.cmi typing/types.cmi typing/typedtree.cmi \
+    typing/printtyp.cmi typing/predef.cmi typing/path.cmi \
+    parsing/parsetree.cmi utils/misc.cmi parsing/longident.cmi \
+    parsing/location.cmi typing/ident.cmi typing/env.cmi typing/ctype.cmi \
+    typing/btype.cmi parsing/asttypes.cmi parsing/ast_helper.cmi \
+    typing/trx.cmi
+typing/trx.cmx : utils/warnings.cmx typing/types.cmx typing/typedtree.cmx \
+    typing/printtyp.cmx typing/predef.cmx typing/path.cmx \
+    parsing/parsetree.cmi utils/misc.cmx parsing/longident.cmx \
+    parsing/location.cmx typing/ident.cmx typing/env.cmx typing/ctype.cmx \
+    typing/btype.cmx parsing/asttypes.cmi parsing/ast_helper.cmx \
+    typing/trx.cmi
+typing/trx.cmi : typing/types.cmi typing/typedtree.cmi parsing/parsetree.cmi \
+    parsing/longident.cmi parsing/location.cmi typing/env.cmi \
+    parsing/asttypes.cmi
 typing/typeclass.cmo : utils/warnings.cmi typing/typetexp.cmi \
     typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi \
     typing/typecore.cmi typing/subst.cmi typing/stypes.cmi \
@@ -354,7 +369,7 @@ typing/typeclass.cmi : typing/types.cmi typing/typedtree.cmi \
     parsing/parsetree.cmi parsing/longident.cmi parsing/location.cmi \
     typing/ident.cmi typing/env.cmi typing/ctype.cmi parsing/asttypes.cmi
 typing/typecore.cmo : utils/warnings.cmi typing/typetexp.cmi \
-    typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi \
+    typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi typing/trx.cmi \
     typing/subst.cmi typing/stypes.cmi typing/printtyp.cmi \
     typing/primitive.cmi typing/predef.cmi typing/path.cmi \
     parsing/parsetree.cmi typing/parmatch.cmi typing/oprint.cmi \
@@ -364,7 +379,7 @@ typing/typecore.cmo : utils/warnings.cmi typing/typetexp.cmi \
     parsing/asttypes.cmi parsing/ast_helper.cmi typing/annot.cmi \
     typing/typecore.cmi
 typing/typecore.cmx : utils/warnings.cmx typing/typetexp.cmx \
-    typing/types.cmx typing/typedtree.cmx typing/typedecl.cmx \
+    typing/types.cmx typing/typedtree.cmx typing/typedecl.cmx typing/trx.cmx \
     typing/subst.cmx typing/stypes.cmx typing/printtyp.cmx \
     typing/primitive.cmx typing/predef.cmx typing/path.cmx \
     parsing/parsetree.cmi typing/parmatch.cmx typing/oprint.cmx \
diff --git a/Makefile b/Makefile
index 85be2db..68c2bc9 100644
--- a/Makefile
+++ b/Makefile
@@ -38,6 +38,8 @@ all:
 	$(MAKE) otherlibraries $(WITH_DEBUGGER) \
 	  $(WITH_OCAMLDOC)
 
+# NNN make all && (cd metalib && make clean all) && (make install; cd metalib && make install)
+
 # Compile everything the first time
 world:
 	$(MAKE) coldstart
@@ -240,6 +242,13 @@ install:
 	   $(INSTALL_COMPLIBDIR)
 	cp expunge $(INSTALL_LIBDIR)/expunge$(EXE)
 	cp toplevel/topdirs.cmi $(INSTALL_LIBDIR)
+# NNN typing/trx.ml needs its own interface (since it looks up identifiers
+# in itself)
+# Although typing/trx.cmi is already copied, see above, it is copied
+# into $(COMPLIBDIR). We need trx.cmi in the standard .cmi search path.
+	cp typing/trx.cmi $(INSTALL_LIBDIR)
+# BTW, trx.cmo is part of ocamlcommon.cma
+# NNN end
 	cd tools; $(MAKE) install
 	-cd man; $(MAKE) install
 	for i in $(OTHERLIBRARIES); do \
diff --git a/Makefile.shared b/Makefile.shared
index 5ffccb4..0d1e7f8 100644
--- a/Makefile.shared
+++ b/Makefile.shared
@@ -28,6 +28,9 @@ COMPFLAGS=-strict-sequence -principal -absname -w +a-4-9-41-42-44-45-48 \
 	  -warn-error A \
           -bin-annot -safe-string -strict-formats $(INCLUDES)
 LINKFLAGS=
+# For debugging
+# COMPFLAGS=-warn-error A -g $(INCLUDES) # NNN
+# LINKFLAGS=-g #NNN
 
 YACCFLAGS=-v --strict
 CAMLLEX=$(CAMLRUN) boot/ocamllex
@@ -57,6 +60,7 @@ PARSING=parsing/location.cmo parsing/longident.cmo \
   parsing/ast_mapper.cmo parsing/ast_iterator.cmo parsing/attr_helper.cmo \
   parsing/builtin_attributes.cmo parsing/ast_invariants.cmo parsing/depend.cmo
 
+# NNN (trx)
 TYPING=typing/ident.cmo typing/path.cmo \
   typing/primitive.cmo typing/types.cmo \
   typing/btype.cmo typing/oprint.cmo \
@@ -69,6 +73,7 @@ TYPING=typing/ident.cmo typing/path.cmo \
   typing/tast_mapper.cmo \
   typing/cmt_format.cmo typing/untypeast.cmo \
   typing/includemod.cmo typing/typetexp.cmo typing/parmatch.cmo \
+  typing/trx.cmo \
   typing/stypes.cmo typing/typedecl.cmo typing/typecore.cmo \
   typing/typeclass.cmo \
   typing/typemod.cmo
diff --git a/parsing/lexer.mll b/parsing/lexer.mll
index a485f3e..1a4854d 100644
--- a/parsing/lexer.mll
+++ b/parsing/lexer.mll
@@ -290,6 +290,8 @@ let identchar_latin1 =
   ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
 let symbolchar =
   ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~']
+let symbolcharnodot =                                                       (* NNN *)
+  ['!' '$' '%' '&' '*' '+' '-'     '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] (* NNN *)
 let decimal_literal =
   ['0'-'9'] ['0'-'9' '_']*
 let hex_literal =
@@ -323,6 +325,9 @@ rule token = parse
         EOL }
   | blank +
       { token lexbuf }
+  | ".<" { DOTLESS }     (* NNN *)
+  | ">." { GREATERDOT }  (* NNN *)
+  | ".~" { DOTTILDE }    (* NNN *)
   | "_"
       { UNDERSCORE }
   | "~"
@@ -503,8 +508,10 @@ rule token = parse
             { PREFIXOP(Lexing.lexeme lexbuf) }
   | ['~' '?'] symbolchar +
             { PREFIXOP(Lexing.lexeme lexbuf) }
-  | ['=' '<' '>' '|' '&' '$'] symbolchar *
+  | ['=' '<' '|' '&' '$'] symbolchar *	         (* NNN: ">." is not INFIXOP0 *)
             { INFIXOP0(Lexing.lexeme lexbuf) }
+  | ['>'] symbolcharnodot symbolchar *           (* NNN exclude ">." case *)
+            { INFIXOP0(Lexing.lexeme lexbuf) }   (* NNN *)
   | ['@' '^'] symbolchar *
             { INFIXOP1(Lexing.lexeme lexbuf) }
   | ['+' '-'] symbolchar *
diff --git a/parsing/parser.mly b/parsing/parser.mly
index 1b642b2..b98d6ff 100644
--- a/parsing/parser.mly
+++ b/parsing/parser.mly
@@ -464,6 +464,9 @@ let package_type_of_module_type pmty =
 
 /* Tokens */
 
+%token DOTLESS     /* NNN */
+%token GREATERDOT  /* NNN */
+%token DOTTILDE    /* NNN */
 %token AMPERAMPER
 %token AMPERSAND
 %token AND
@@ -649,7 +652,7 @@ The precedences must be listed from low to high.
           LBRACE LBRACELESS LBRACKET LBRACKETBAR LIDENT LPAREN
           NEW PREFIXOP STRING TRUE UIDENT
           LBRACKETPERCENT LBRACKETPERCENTPERCENT
-
+          DOTLESS DOTTILDE             /* NNN */
 
 /* Entry points */
 
@@ -1480,6 +1483,12 @@ simple_expr:
       { reloc_exp $2 }
   | LPAREN seq_expr error
       { unclosed "(" 1 ")" 3 }
+  | DOTLESS expr GREATERDOT                 /* NNN */
+      { wrap_exp_attrs $2 
+           (None,[ghloc "metaocaml.bracket",PStr []]) }            /* NNN */
+  | DOTTILDE simple_expr  /* NNN */
+      { wrap_exp_attrs $2 
+           (None,[ghloc "metaocaml.escape",PStr []]) }             /* NNN */
   | BEGIN ext_attributes seq_expr END
       { wrap_exp_attrs (reloc_exp $3) $2 (* check location *) }
   | BEGIN ext_attributes END
diff --git a/parsing/pprintast.ml b/parsing/pprintast.ml
index f9e5152..b480941 100644
--- a/parsing/pprintast.ml
+++ b/parsing/pprintast.ml
@@ -47,6 +47,8 @@ let fixity_of_string  = function
 
 let view_fixity_of_exp = function
   | {pexp_desc = Pexp_ident {txt=Lident l;_};_} -> fixity_of_string l
+  | {pexp_desc = Pexp_ident {txt=Ldot (Lident "Pervasives",l);_};_} ->  (*NNN*)
+      fixity_of_string l                                                (*NNN*)
   | _ -> `Normal  ;;
 
 let is_infix  = function  | `Infix _ -> true | _  -> false
@@ -486,10 +488,45 @@ and sugar_expr ctxt f e =
   | _ -> false
 
 and expression ctxt f x =
-  if x.pexp_attributes <> [] then
-    pp f "((%a)@,%a)" (expression ctxt) {x with pexp_attributes=[]}
-      (attributes ctxt) x.pexp_attributes
-  else match x.pexp_desc with
+    (* NNN begin *)
+    (* Keep in mind that there may be several metaocaml
+       attributes, and the order matters *)
+    (* Here we assume that all metaocaml attributes are at the front,
+       which is how they are generated.
+    *)
+    match x.pexp_attributes with
+    | ({txt="metaocaml.bracket"},_) :: t ->
+        pp f "@[<hov2>.<@ %a @ >.@]" 
+          (expression ctxt) {x with pexp_attributes=t}
+    | ({txt="metaocaml.escape"},_) :: t ->
+        begin
+        match x.pexp_desc with
+        | Pexp_ident li when t = [] -> pp f ".~%a" longident_loc li
+        | _ -> pp f ".~%a" (paren true (expression ctxt))
+                              {x with pexp_attributes=t}
+        end
+    | [({txt = "metaocaml.csp"},PStr [{pstr_desc = 
+            Pstr_eval ({pexp_desc=Pexp_ident li},_)}])] -> 
+              begin
+                (* This CSP is easy to print, so we print it *)
+                match x.pexp_desc with
+                | Pexp_apply (_,
+                    [(Nolabel, {pexp_desc=Pexp_constant (Pconst_integer _)})])
+                    -> 
+                      pp f "(* CSP %a *) %a"
+                        longident_loc li
+                        (expression ctxt) {x with pexp_attributes=[]}
+                | _ -> 
+                      pp f "(* CSP %a *)"
+                        longident_loc li
+              end
+    (* if x.pexp_attributes <> [] then *)
+    | _::_ ->
+      pp f "((%a)@,%a)" (expression ctxt) {x with pexp_attributes=[]}
+        (attributes ctxt) x.pexp_attributes
+    | _ -> begin match x.pexp_desc with
+    (* else match x.pexp_desc with *)
+    (* NNN end *)
     | Pexp_function _ | Pexp_fun _ | Pexp_match _ | Pexp_try _ | Pexp_sequence _
       when ctxt.pipe || ctxt.semi ->
         paren true (expression reset_ctxt) f x
@@ -623,6 +660,7 @@ and expression ctxt f x =
     | Pexp_extension e -> extension ctxt f e
     | Pexp_unreachable -> pp f "."
     | _ -> expression1 ctxt f x
+   end (* NNN *)
 
 and expression1 ctxt f x =
   if x.pexp_attributes <> [] then expression ctxt f x
diff --git a/typing/predef.ml b/typing/predef.ml
index a16997f..0e0ce79 100644
--- a/typing/predef.ml
+++ b/typing/predef.ml
@@ -146,6 +146,17 @@ and ident_nil = ident_create "[]"
 and ident_cons = ident_create "::"
 and ident_none = ident_create "None"
 and ident_some = ident_create "Some"
+
+(* NNN ident_create "code" must be placed at the end of all other
+   ident creation expressions, to make sure that creating ident_code
+   does not shift the timestamps of other standard idents like 
+   Eof, etc. Otherwise, binary compatibility with OCaml breaks,
+   and we have to do the expensive bootstrapping.
+*)
+let ident_code = ident_create "code"    (* NNN *)
+let path_code  = Pident ident_code      (* NNN *)
+let type_code t = newgenty (Tconstr(path_code, [t], ref Mnil)) (* NNN *)
+
 let common_initial_env add_type add_extension empty_env =
   let decl_bool =
     {decl_abstr with
@@ -185,6 +196,13 @@ let common_initial_env add_type add_extension empty_env =
      type_params = [tvar];
      type_arity = 1;
      type_variance = [Variance.covariant]}
+      (* NNN added decl_code *)
+  and decl_code =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_variance = [Variance.covariant]}
   in
 
   let add_extension id l =
@@ -214,6 +232,7 @@ let common_initial_env add_type add_extension empty_env =
                          [newgenty (Ttuple[type_string; type_int; type_int])] (
   add_extension ident_undefined_recursive_module
                          [newgenty (Ttuple[type_string; type_int; type_int])] (
+  add_type ident_code decl_code (       (* NNN *)
   add_type ident_int64 decl_abstr (
   add_type ident_int32 decl_abstr (
   add_type ident_nativeint decl_abstr (
@@ -229,7 +248,8 @@ let common_initial_env add_type add_extension empty_env =
   add_type ident_char decl_abstr_imm (
   add_type ident_int decl_abstr_imm (
   add_type ident_extension_constructor decl_abstr (
-    empty_env)))))))))))))))))))))))))))
+    empty_env)))))))))))))))))))))))))))) (* NNN extra parenthesis *)
+
 
 let build_initial_env add_type add_exception empty_env =
   let common = common_initial_env add_type add_exception empty_env in
diff --git a/typing/predef.mli b/typing/predef.mli
index a7bf063..4086fbc 100644
--- a/typing/predef.mli
+++ b/typing/predef.mli
@@ -32,6 +32,7 @@ val type_nativeint: type_expr
 val type_int32: type_expr
 val type_int64: type_expr
 val type_lazy_t: type_expr -> type_expr
+val type_code:   type_expr -> type_expr (* NNN *)
 val type_extension_constructor:type_expr
 
 val path_int: Path.t
@@ -49,6 +50,7 @@ val path_nativeint: Path.t
 val path_int32: Path.t
 val path_int64: Path.t
 val path_lazy_t: Path.t
+val path_code: Path.t  (* NNN *)
 val path_extension_constructor: Path.t
 
 val path_match_failure: Path.t
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 116dc1b..5204a95 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -103,6 +103,101 @@ let type_object =
        Env.t -> Location.t -> Parsetree.class_structure ->
          Typedtree.class_structure * Types.class_signature * string list)
 
+(* NNN: begin
+  The current stage level.
+  Type-checking the body of a bracket increases the level,
+  type-checking of an escape decreases.
+  Be sure to reset upon any exception;
+  alternatively; reset when beginning a new type-level
+  expression or binding
+  (whenever you do Typetexp.reset_type_variables();)
+
+ Check all instances of Env.add_value and Env.enter_value and Texp_ident
+  make sure that
+ we record the stage of every identifier that is added to the
+ value env (unless the stage is 0).
+also check all val_attributes and Val_reg
+*)
+let global_stage : Trx.stage ref  = ref 0
+
+(* Obsolete; kept for reference 
+
+  The list of active classifiers. The length of the list
+  is the level of an expression.
+  Type-checking the body of a bracket adds a type variable
+  to the list; type-checking of an escape removes the
+  top-most classifier.
+  Be sure to reset this list upon any exception;
+  alternatively; reset the list when beginning a new type-level
+  expression or binding
+  (whenever you do Typetexp.reset_type_variables();)
+
+let global_stage : Env.stage ref  = ref []
+
+   Unify classifier lists, *right-to-left*
+   See the bug Tue Jan 20 12:18:00 GMTST 2004 in XXCC-BUG-OPEN-FIXED
+   why we need this order.
+   The current classifier is left-most, and the lists don't have
+   to have the same length.
+   Example:
+   .<fun x -> .< x >. >.
+   When type-checking the innermost bracket, the global_stage
+   will contain ['b,'a] and the level of x will be ['a]
+   The unification will succeed, without changing anything, as expected.
+
+let unify_stage env tl1 tl2 =
+   let rec loop = function
+   | (t1::tl1,t2::tl2) -> unify env t1 t2; loop (tl1,tl2)
+   | _ -> ()
+   in loop (List.rev tl1, List.rev tl2)
+*)
+
+(* This function does not take the env argument. Normally env affects
+   the printing of paths (search for raise_wrong_stage_error
+   in this file and printtyp.ml).
+ The particular error message we emit here does not use paths.
+*)
+let raise_wrong_stage_error loc n m =
+  raise @@ Error_forward(match (n,m) with
+  | (1,0) -> Location.errorf ~loc 
+    "A variable that was bound within brackets is used outside brackets\n\
+for example: .<fun x -> .~(foo x)>.\n\
+Hint: enclose the variable in brackets,\nas in: .<fun x -> .~(foo .<x>.)>.;;"
+  | _ -> Location.errorf ~loc 
+   "Wrong level: variable bound at level %d and used at level %d" n m)
+
+let raise_unsupported loc txt =
+  raise @@
+  Error_forward(Location.errorf ~loc 
+                  "Not supported within brackets: %s" txt)
+
+let with_stage_up body =
+   let old_stage = !global_stage in
+   let () = incr global_stage in
+   try 
+    let r = body () in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+
+let with_stage_down loc _env body =
+   let old_stage = !global_stage in
+   if !global_stage = 0 then
+     raise @@ Error_forward(Location.errorf ~loc 
+       "An escape may appear only within brackets");
+   decr global_stage;
+   try 
+    let r = body () in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+
+let pat_code_path =
+  Path.(Pdot (Pident (Ident.create_persistent "Trx"), "pat_code", 0))
+let val_code_path =
+  Path.(Pdot (Pident (Ident.create_persistent "Trx"), "val_code", 0))
+(* NNN end *)
+
 (*
   Saving and outputting type information.
   We keep these function names short, because they have to be
@@ -1437,7 +1532,7 @@ let add_pattern_variables ?check ?check_as env =
        let check = if as_var then check_as else check in
        Env.add_value ?check id
          {val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
-          val_attributes = [];
+          val_attributes = [Trx.attr_level !global_stage];   (* NNN *)
          } env
      )
      pv env,
@@ -1480,7 +1575,8 @@ let type_class_arg_pattern cl_num val_env met_env l spat =
          ((id', name, id, ty)::pv,
           Env.add_value id' {val_type = ty;
                              val_kind = Val_ivar (Immutable, cl_num);
-                             val_attributes = [];
+                             val_attributes = 
+                                   [Trx.attr_level !global_stage];    (* NNN *)
                              Types.val_loc = loc;
                             } ~check
             env))
@@ -1504,6 +1600,10 @@ let type_self_pattern cl_num privty val_env met_env par_env spat =
   let pv = !pattern_variables in
   pattern_variables := [];
   let (val_env, met_env, par_env) =
+	  (* NNN we don't record stage for
+	     Env.add_value below
+	     since we don't handle classes within brackets.
+	   *)
     List.fold_right
       (fun (id, ty, _name, loc, as_var) (val_env, met_env, par_env) ->
          (Env.add_value id {val_type = ty;
@@ -1556,6 +1656,7 @@ let rec final_subexpression sexp =
 (* Generalization criterion for expressions *)
 
 let rec is_nonexpansive exp =
+  List.memq Trx.attr_nonexpansive exp.exp_attributes ||   (* NNN *)
   match exp.exp_desc with
     Texp_ident(_,_,_) -> true
   | Texp_constant _ -> true
@@ -1675,7 +1776,14 @@ let rec approx_type env sty =
       approx_type env sty
   | _ -> newvar ()
 
-let rec type_approx env sexp =
+let rec type_approx env sexp =          (* NNN the whole function *)
+  let open Trx in
+  match what_stage_attr sexp.pexp_attributes with
+  | Stage0 -> type_approx_orig env sexp
+    (* instance env @@ Predef.type_code @@ type_approx_orig env sexp *)
+  | _ -> newvar ()
+and
+  type_approx_orig env sexp =          (* NNN end *)
   match sexp.pexp_desc with
     Pexp_let (_, _, e) -> type_approx env e
   | Pexp_fun (p, _, _, e) ->
@@ -1936,8 +2044,148 @@ and type_expect ?in_function ?recarg env sexp ty_expected =
     (Cmt_format.Partial_expression exp :: previous_saved_types);
   exp
 
+(* NNN This whole function type_expect_ *)
+(* Type checking staging constructs *)
+(* If we are type-checking bracket at level 0, don't build the
+   bracket Texp node. Rather, invoke trx_bracket to translate 
+   the bracket body and convert it to the code generator.
+*)
 and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
   let loc = sexp.pexp_loc in
+  let open Trx in
+  (* Keep in mind that there may be several metaocaml attributes,
+     and their order matters. 
+  *)
+  match what_stage_attr sexp.pexp_attributes with
+  | Stage0 -> type_expect_orig ?in_function ~recarg env sexp ty_expected
+
+        (* the programmer asserts that the bracketed expression is
+           a functional literal. Check it, and if so, give it a more
+           refined type: pat_code
+         *)
+  | FunBracket(battrs,attrs) ->
+     let literal_fn = 
+       (* If there are other staging attributes _underneath_, 
+          the quoted expression
+          has brackets and escapes and hence cannot be a function literal
+        *)
+       if what_stage_attr attrs <> Stage0 then false
+       else match sexp.pexp_desc with
+       | Pexp_fun (Nolabel, None, _, _) 
+       | Pexp_function _ -> true
+       | _               -> false
+     in
+     let () = if not literal_fn then 
+       raise @@ Error_forward(Location.errorf ~loc 
+       "The expression does not appear to be a functional literal as \
+        requested") in
+     (* check to make sure pat_code is really the type 'a pat_code
+        that we declared in Trx.mli
+      *)
+     let () = 
+       match Env.find_type pat_code_path Env.initial_safe_string with
+       | {type_params = [_]} -> ()
+       | _                   -> assert false 
+     in
+     let ty = newgenvar() in     (* expected type for the bracketed sexp *)
+     let type_pat_code = newgenty (Tconstr(pat_code_path, [ty], ref Mnil)) in
+     unify_exp_types loc env type_pat_code ty_expected;
+     let exp =
+        with_stage_up (fun () ->
+                (* drop bracket attr *)
+          let sexp = {sexp with pexp_attributes = attrs} in
+          type_expect env sexp ty) in
+     re @@
+      if !global_stage = 0 then
+        (* Function literal is certainly a value *)
+        let exp = trx_bracket 1 exp in
+        {exp with exp_type = instance env ty_expected;
+                  exp_attributes = attr_nonexpansive :: exp.exp_attributes}
+      else
+        texp_braesc battrs exp env (instance env ty_expected)
+
+        (* the programmer asserts that the bracketed expression represents
+           a value in the generated code. When such an expression is
+           evaluated in the future, it has no side effects
+           (except for heap allocations).
+           Check this assertion, and if so, give it a more refined type: 
+           val_code
+         *)
+  | ValBracket(battrs,attrs) ->
+                (* drop bracket attr *)
+     let sexp1 = {sexp with pexp_attributes = attrs} in
+     let () = if not (Trx.is_value_exp 0 sexp1) then 
+       raise @@ Error_forward(Location.errorf ~loc 
+       "The expression does not appear to be syntactically a value as \
+        requested") in
+     (* check to make sure val_code is really the type 'a val_code
+        that we declared in Trx.mli
+      *)
+     let () = 
+       match Env.find_type val_code_path Env.initial_safe_string with
+       | {type_params = [_]} -> ()
+       | _                   -> assert false 
+     in
+     let ty = newgenvar() in     (* expected type for the bracketed sexp *)
+     let type_val_code = newgenty (Tconstr(val_code_path, [ty], ref Mnil)) in
+     unify_exp_types loc env type_val_code ty_expected;
+     let exp =
+        with_stage_up (fun () -> type_expect env sexp1 ty) in
+     re @@
+      if !global_stage = 0 then
+        (* Value is certainly non-expansive *)
+        let exp = trx_bracket 1 exp in
+        {exp with exp_type = instance env ty_expected;
+                  exp_attributes = attr_nonexpansive :: exp.exp_attributes}
+      else
+        texp_braesc battrs exp env (instance env ty_expected)
+
+  | Bracket(battrs,attrs) ->
+       (* Typechecking bracket *)
+       (* follow Pexp_array or Pexp_lazy as a template *)
+       (* Expected type: ty code where ty is the type
+          of the expression within brackets.
+        *)
+      let ty = newgenvar() in     (* expected type for the bracketed sexp *)
+      let to_unify = Predef.type_code ty in
+      unify_exp_types loc env to_unify ty_expected;
+      let exp =
+        with_stage_up (fun () ->
+                (* drop bracket attr *)
+          let sexp = {sexp with pexp_attributes = attrs} in
+          type_expect env sexp ty) in
+      re @@
+      if !global_stage = 0 then
+        (* Check if the expression non-expansive before the translation *)
+        let nonexp = is_nonexpansive exp in
+        let exp = trx_bracket 1 exp in
+        {exp with exp_type = instance env ty_expected;
+                  exp_attributes = 
+                    if nonexp then attr_nonexpansive :: exp.exp_attributes
+                              else exp.exp_attributes}
+      else
+        texp_braesc battrs exp env (instance env ty_expected)
+
+       (* NNN:  Typechecking escapes *)
+       (* If ~e is expected to have the type ty then
+          e is expected to have the type ty code
+        *)
+  | Escape(battr,attrs) ->    
+      with_stage_down loc env (fun () ->
+       let sexp_ty_expected = Predef.type_code ty_expected in
+       let sexp = {sexp with pexp_attributes = attrs} in (* drop bracket attr *)
+       let exp = type_expect env sexp sexp_ty_expected in
+       re @@
+         texp_braesc [battr] exp env (instance env ty_expected))
+
+       (* There is nothing special in type-checking CSPs.
+          After lifting, a CSP value becomes an ordinary expression.
+        *)
+  | CSP _ -> type_expect_orig ?in_function ~recarg env sexp ty_expected
+  (* NNN end *)
+
+and type_expect_orig ?in_function ~recarg env sexp ty_expected =  (* NNN *)
+  let loc = sexp.pexp_loc in
   (* Record the expression type before unifying it with the expected type *)
   let rue exp =
     unify_exp env (re exp) (instance env ty_expected);
@@ -1973,6 +2221,7 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
         | false, Required, _  ->
             () (* will fail later *)
         end;
+        let stage = Trx.get_level desc.val_attributes in        (* NNN *)
         rue {
           exp_desc =
             begin match desc.val_kind with
@@ -1996,9 +2245,13 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
                 Env.add_required_global (Path.head p);
                 Texp_ident(path, lid, desc)*)
             | _ ->
+              if stage > !global_stage then                          (* NNN *)
+                 raise_wrong_stage_error loc stage !global_stage     (* NNN *)
+	      else                                                   (* NNN *)
                 Texp_ident(path, lid, desc)
           end;
           exp_loc = loc; exp_extra = [];
+(* NNN:  Instantiates type scheme to a type *)
           exp_type = instance env desc.val_type;
           exp_attributes = sexp.pexp_attributes;
           exp_env = env }
@@ -2447,7 +2700,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
         | Ppat_any -> Ident.create "_for", env
         | Ppat_var {txt} ->
             Env.enter_value txt {val_type = instance_def Predef.type_int;
-                                 val_attributes = [];
+                                 val_attributes =     (* NNN *)
+                                     [Trx.attr_level !global_stage];
                                  val_kind = Val_reg; Types.val_loc = loc; } env
               ~check:(fun s -> Warnings.Unused_for_index s)
         | _ ->
@@ -2616,7 +2870,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
                                 Texp_ident(Path.Pident method_id, lid,
                                            {val_type = method_type;
                                             val_kind = Val_reg;
-                                            val_attributes = [];
+                                            val_attributes =        (* NNN *)
+                                               [Trx.attr_level !global_stage]; 
                                             Types.val_loc = Location.none});
                                 exp_loc = loc; exp_extra = [];
                                 exp_type = method_type;
@@ -2701,6 +2956,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
               exp_env = env }
         end
   | Pexp_setinstvar (lab, snewval) ->
+      if !global_stage != 0 then                                      (* NNN *)
+        raise_unsupported loc "setinstvar";                           (* NNN *)
       begin try
         let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
         match desc.val_kind with
@@ -2731,6 +2988,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
                       Unbound_instance_variable (lab.txt, valid_vars)))
       end
   | Pexp_override lst ->
+      if !global_stage != 0 then                                    (* NNN *)
+        raise_unsupported loc "override";                           (* NNN *)
       let _ =
        List.fold_right
         (fun (lab, _) l ->
@@ -2771,6 +3030,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
           assert false
       end
   | Pexp_letmodule(name, smodl, sbody) ->
+      if !global_stage != 0 then                                    (* NNN *)
+        raise_unsupported loc "letmodule";                          (* NNN *)
       let ty = newvar() in
       (* remember original level *)
       begin_def ();
@@ -2800,6 +3061,8 @@ and type_expect_ ?in_function ?(recarg=Rejected) env sexp ty_expected =
         exp_attributes = sexp.pexp_attributes;
         exp_env = env }
   | Pexp_letexception(cd, sbody) ->
+      if !global_stage != 0 then                                    (* NNN *)
+        raise_unsupported loc "letexception";                       (* NNN *)
       let (cd, newenv) = Typedecl.transl_exception env cd in
       let body = type_expect newenv sbody ty_expected in
       re {
@@ -3429,7 +3692,7 @@ and type_argument ?recarg env sarg ty_expected' ty_expected =
          exp_desc =
          Texp_ident(Path.Pident id, mknoloc (Longident.Lident name),
                     {val_type = ty; val_kind = Val_reg;
-                     val_attributes = [];
+                     val_attributes = [Trx.attr_level !global_stage]; (* NNN *)
                      Types.val_loc = Location.none})}
       in
       let eta_pat, eta_var = var_pair "eta" ty_arg in
@@ -4134,6 +4397,7 @@ and type_let ?(check = fun s -> Warnings.Unused_var s)
 (* Typing of toplevel bindings *)
 
 let type_binding env rec_flag spat_sexp_list scope =
+  global_stage := 0;			(* NNN *)
   Typetexp.reset_type_variables();
   let (pat_exp_list, new_env, _unpacks) =
     type_let
@@ -4151,18 +4415,35 @@ let type_let env rec_flag spat_sexp_list scope =
 (* Typing of toplevel expressions *)
 
 let type_expression env sexp =
+  global_stage := 0;			(* NNN *)
   Typetexp.reset_type_variables();
   begin_def();
   let exp = type_exp env sexp in
   end_def();
   if not (is_nonexpansive exp) then generalize_expansive env exp.exp_type;
   generalize exp.exp_type;
+  (* NNN The original code 
   match sexp.pexp_desc with
     Pexp_ident lid ->
       (* Special case for keeping type variables when looking-up a variable *)
       let (_path, desc) = Env.lookup_value lid.txt env in
       {exp with exp_type = desc.val_type}
   | _ -> exp
+  We have to modify it since <x> is also Pexp_ident, with the additional
+  attribute though. So, either we have to check for metaocaml.bracket 
+  attribute, or, better, check exp. After type-checking, <x> is no longer
+  Pexp_ident. For ordinary identifiers though, Pexp_ident li maps to
+  Texp_ident (..,li,..) -- with the exception of instance vars, which
+  don't matter at the toplevel anyway.
+*)
+ (* NNN new code *)
+  match exp.exp_desc with
+    Texp_ident (_,lid,_) ->
+      (* Special case for keeping type variables when looking-up a variable *)
+      let (_path, desc) = Env.lookup_value lid.txt env in
+      {exp with exp_type = desc.val_type}
+  | _ -> exp
+ (* NNN end *)
 
 (* Error report *)
 
